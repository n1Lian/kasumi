#include "Kasumi.h"

Kasumi::Kasumi()
{

}

/*
----------------------------------------------
Длина ключа - 128 бит
Делится на 8 кусочков по 16 бит
----------------------------------------------
*/

void Kasumi::setKey(u8* key_full)
{
	u16 key_first[8], key_final[8];
	static const u16 C[] = { 0x0123, 0x4567, 0x89AB, 0xCDEF, 0xFEDC, 0xBA98, 0x7654, 0x3210 };

	WORD16* key_tmp;
	key_tmp = (WORD16*)key_full;

	// Разбиваем главный ключ(128 бит) на части поменьше(8 * 16 бит)
	for (int i = 0; i < 8; i++)
	{
		key_first[i] = (u16)((key_tmp[i].b8[0]) + (key_tmp[i].b8[1]));
	}

	// Теперь преобразуем промежуточный ключ в конечный
	for (int i = 0; i < 8; i++)
	{
		key_final[i] = (u16)(key_first[i] ^ C[i]);
	}

	// Рассчитываем ключи для каждого раунда
	// 0x7 при побитовом И с 8 = 0 --> 8 & 0x7 = 0
	for (int i = 0; i < 8; i++)
	{
		KL_1[i] = ROL16(key_first[i], 1);
		KL_2[i] = key_final[(i + 2) & 0x7];
		KO_1[i] = ROL16(key_first[(i + 1) & 0x7], 5);
		KO_2[i] = ROL16(key_first[(i + 5) & 0x7], 8);
		KO_3[i] = ROL16(key_first[(i + 6) & 0x7], 13);
		KI_1[i] = key_final[(i + 4) & 0x7];
		KI_2[i] = key_final[(i + 3) & 0x7];
		KI_3[i] = key_final[(i + 7) & 0x7];
	}
}

/*
----------------------------------------------
FL()
Принимает текст(32 бит) и делит его на 2 части(16 бит)
В теории и ключ также, но я его разделил еще в хедере. Так проще
----------------------------------------------
*/

u32 Kasumi::FL(u32 input, int key_index)
{
	u16 main_l, main_r, tmp_l, tmp_r; // main_l - main left side(right side), tmp_l - tmp left side(right side)

	// Делим на 2 части по 16 бит путем сдвига битов и последующей обрезки потока
	main_l = (u16)(input >> 16);
	main_r = (u16)(input);

	// Операции функции FL()
	tmp_r = (u16)(main_l & KL_1[key_index]);
	main_r ^= ROL16(tmp_r, 1);
	tmp_l = (u16)(main_r | KL_2[key_index]);
	main_l ^= ROL16(tmp_l, 1);

	// Объединяем две части
	input = (((u32)main_l) << 16) | main_r;

	return input;
}

/*
----------------------------------------------
FO()
----------------------------------------------
*/

u32 Kasumi::FO(u32 input, int key_index)
{
	u16 main_l, main_r, tmp_l, tmp_r;

	main_l = (u16)(input >> 16);
	main_r = (u16)(input);

	// Операции функции FO()
	tmp_r = main_l ^ KO_1[key_index]; // tmp_r = L0 ^ KO_1
	tmp_l = main_r; //  tmp_l = R0
	main_r = FI(tmp_r, KI_1[key_index]) ^ main_r; // R1 = FI() ^ R0
	main_l = tmp_l; // L1 = R0

	tmp_r = main_l ^ KO_2[key_index]; // tmp_r = L1 ^ KO_2
	tmp_l = main_r; //  tmp_l = R1
	main_r = FI(tmp_r, KI_2[key_index]) ^ main_r; // R2 = FI() ^ R1
	main_l = tmp_l; // L2 = R1

	tmp_r = main_l ^ KO_3[key_index]; // tmp_r = L2 ^ KO_3
	tmp_l = main_r; //  tmp_l = R2
	main_r = FI(tmp_r, KI_3[key_index]) ^ main_r; // R3 = FI() ^ R2
	main_l = tmp_l; // L3 = R2

	input = (((u32)main_l) << 16) | main_r;

	return input;
}

/*
----------------------------------------------
FO()
----------------------------------------------
*/

u16 Kasumi::FI(u16 input, u16 subkey)
{
	static u16 S7[] =
	{
			54, 50, 62, 56, 22, 34, 94, 96, 38, 6, 63, 93, 2, 18, 123, 33,
			55, 113, 39, 114, 21, 67, 65, 12, 47, 73, 46, 27, 25, 111, 124, 81,
			53, 9, 121, 79, 52, 60, 58, 48, 101, 127, 40, 120, 104, 70, 71, 43,
			20, 122, 72, 61, 23, 109, 13, 100, 77, 1, 16, 7, 82, 10, 105, 98,
			117, 116, 76, 11, 89, 106, 0, 125, 118, 99, 86, 69, 30, 57, 126, 87,
			112, 51, 17, 5, 95, 14, 90, 84, 91, 8, 35, 103, 32, 97, 28, 66,
			102, 31, 26, 45, 75, 4, 85, 92, 37, 74, 80, 49, 68, 29, 115, 44,
			64, 107, 108, 24, 110, 83, 36, 78, 42, 19, 15, 41, 88, 119, 59, 3
	};

	static u16 S9[] =
	{
			167, 239, 161, 379, 391, 334, 9, 338, 38, 226, 48, 358, 452, 385, 90, 397,
			183, 253, 147, 331, 415, 340, 51, 362, 306, 500, 262, 82, 216, 159, 356, 177,
			175, 241, 489, 37, 206, 17, 0, 333, 44, 254, 378, 58, 143, 220, 81, 400,
			95, 3, 315, 245, 54, 235, 218, 405, 472, 264, 172, 494, 371, 290, 399, 76,
			165, 197, 395, 121, 257, 480, 423, 212, 240, 28, 462, 176, 406, 507, 288, 223,
			501, 407, 249, 265, 89, 186, 221, 428, 164, 74, 440, 196, 458, 421, 350, 163,
			232, 158, 134, 354, 13, 250, 491, 142, 191, 69, 193, 425, 152, 227, 366, 135,
			344, 300, 276, 242, 437, 320, 113, 278, 11, 243, 87, 317, 36, 93, 496, 27,
			487, 446, 482, 41, 68, 156, 457, 131, 326, 403, 339, 20, 39, 115, 442, 124,
			475, 384, 508, 53, 112, 170, 479, 151, 126, 169, 73, 268, 279, 321, 168, 364,
			363, 292, 46, 499, 393, 327, 324, 24, 456, 267, 157, 460, 488, 426, 309, 229,
			439, 506, 208, 271, 349, 401, 434, 236, 16, 209, 359, 52, 56, 120, 199, 277,
			465, 416, 252, 287, 246, 6, 83, 305, 420, 345, 153, 502, 65, 61, 244, 282,
			173, 222, 418, 67, 386, 368, 261, 101, 476, 291, 195, 430, 49, 79, 166, 330,
			280, 383, 373, 128, 382, 408, 155, 495, 367, 388, 274, 107, 459, 417, 62, 454,
			132, 225, 203, 316, 234, 14, 301, 91, 503, 286, 424, 211, 347, 307, 140, 374,
			35, 103, 125, 427, 19, 214, 453, 146, 498, 314, 444, 230, 256, 329, 198, 285,
			50, 116, 78, 410, 10, 205, 510, 171, 231, 45, 139, 467, 29, 86, 505, 32,
			72, 26, 342, 150, 313, 490, 431, 238, 411, 325, 149, 473, 40, 119, 174, 355,
			185, 233, 389, 71, 448, 273, 372, 55, 110, 178, 322, 12, 469, 392, 369, 190,
			1, 109, 375, 137, 181, 88, 75, 308, 260, 484, 98, 272, 370, 275, 412, 111,
			336, 318, 4, 504, 492, 259, 304, 77, 337, 435, 21, 357, 303, 332, 483, 18,
			47, 85, 25, 497, 474, 289, 100, 269, 296, 478, 270, 106, 31, 104, 433, 84,
			414, 486, 394, 96, 99, 154, 511, 148, 413, 361, 409, 255, 162, 215, 302, 201,
			266, 351, 343, 144, 441, 365, 108, 298, 251, 34, 182, 509, 138, 210, 335, 133,
			311, 352, 328, 141, 396, 346, 123, 319, 450, 281, 429, 228, 443, 481, 92, 404,
			485, 422, 248, 297, 23, 213, 130, 466, 22, 217, 283, 70, 294, 360, 419, 127,
			312, 377, 7, 468, 194, 2, 117, 295, 463, 258, 224, 447, 247, 187, 80, 398,
			284, 353, 105, 390, 299, 471, 470, 184, 57, 200, 348, 63, 204, 188, 33, 451,
			97, 30, 310, 219, 94, 160, 129, 493, 64, 179, 263, 102, 189, 207, 114, 402,
			438, 477, 387, 122, 192, 42, 381, 5, 145, 118, 180, 449, 293, 323, 136, 380,
			43, 66, 60, 455, 341, 445, 202, 432, 8, 237, 15, 376, 436, 464, 59, 461
	};

	u16 main_l, main_r, tmp_1, tmp_2;

	main_l = (u16)(input >> 7); // Left side
	/*
	1111 1111 1000 0000
	>> 7
	0000 0001 1111 1111
	*/
	main_r = (u16)(input & 0x7F); // Right side
	/*
	1111 1111 1111 1111
	& 0x7F(0000 0000 0111 1111)
	0000 0000 0111 1111
	*/
	main_l = (u16)(S9[main_l] ^ main_r);
	main_r = (u16)(S7[main_r] ^ (main_l & 0x7F));

	main_r ^= (subkey >> 9);
	main_l ^= (subkey & 0x1FF);

	main_l = (u16)(S9[main_l] ^ main_r);
	main_r = (u16)(S7[main_r] ^ (main_l & 0x7F));

	return (u16)(main_r << 9) | main_l;
}

void Kasumi::encryptBlock(u8* data)
{
	u32 left, right, temp;
	WORD32* d;
	int n;
	/* Разбиваем данные на 2 32-разрядных блока */
	d = (WORD32*)data;

	right = (((u32)d[0].b8[0]) << 24) | (((u32)d[0].b8[1]) << 16) | (d[0].b8[2] << 8) | (d[0].b8[3]);
	left = (((u32)d[1].b8[0]) << 24) | (((u32)d[1].b8[1]) << 16) | (d[1].b8[2] << 8) | (d[1].b8[3]);

	n = 0;
	do
	{
		temp = FL(left, n);
		temp = FO(temp, n++);
		right ^= temp;
		temp = FO(right, n);
		temp = FL(temp, n++);
		left ^= temp;
	} while (n <= 7);

	d[1].b8[0] = (u8)(left >> 24);
	d[0].b8[0] = (u8)(right >> 24);
	d[1].b8[1] = (u8)(left >> 16);
	d[0].b8[1] = (u8)(right >> 16);
	d[1].b8[2] = (u8)(left >> 8);
	d[0].b8[2] = (u8)(right >> 8);
	d[1].b8[3] = (u8)(left);
	d[0].b8[3] = (u8)(right);
}

void Kasumi::decryptBlock(u8* data)
{
	u32 left, right, temp;
	WORD32* d;
	int n;
	/* починаємо з введення двох 32-дво бітних значень */
	d = (WORD32*)data;
	right = (((u32)d[0].b8[0]) << 24) | (((u32)d[0].b8[1]) << 16) | (d[0].b8[2] << 8) | (d[0].b8[3]);
	left = (((u32)d[1].b8[0]) << 24) | (((u32)d[1].b8[1]) << 16) | (d[1].b8[2] << 8) | (d[1].b8[3]);

	n = 7;
	do
	{
		temp = FO(right, n);
		temp = FL(temp, n--);
		left ^= temp;
		temp = FL(left, n);
		temp = FO(temp, n--);
		right ^= temp;
	} while (n >= 0);

	/* повертаємо результат */
	d[1].b8[0] = (u8)(left >> 24);
	d[0].b8[0] = (u8)(right >> 24);
	d[1].b8[1] = (u8)(left >> 16);
	d[0].b8[1] = (u8)(right >> 16);
	d[1].b8[2] = (u8)(left >> 8);
	d[0].b8[2] = (u8)(right >> 8);
	d[1].b8[3] = (u8)(left);
	d[0].b8[3] = (u8)(right);
}

void Kasumi::encrypt(string& data)
{

}

void Kasumi::decrypt(string& data)
{

}
